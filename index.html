<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>Chronos - Time Series Manager</title>
    <link rel="icon" type="image/png" href="icon-192.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
    tailwind.config = {
        darkMode: 'class',
    }
    </script>
    <script type="module" src="https://unpkg.com/alpinejs@3.x.x/dist/module.esm.js"></script>
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link href="https://unpkg.com/tabulator-tables@5.6.1/dist/css/tabulator_modern.min.css" rel="stylesheet">
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.6.1/dist/js/tabulator.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script type="module" src="./multiselect.js"></script>
<script type="module" src="./calendar.js"></script>
    <script type="module" src="./db.js"></script>
    <script type="module" src="./seriecard.js"></script>
    <script type="module" src="./analytics.js"></script>
    <script type="module" src="./utils.js"></script>
    <script type="module" src="./chronos-chart.js"></script>
    <script type="module" src="./series-chart.js"></script>
    <script type="module" src="./series-history.js"></script>
    <script type="module" src="./duration-picker-modal.js"></script>
    <script type="module" src="./seriesConfig.js"></script>
    <script type="module" src="./groupcard.js"></script>
    <script type="module" src="./group-manager.js"></script>
    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* Better touch targets for mobile inputs */
        @media (max-width: 640px) {
            input, select, button {
                min-height: 44px; /* Apple/Google recommended touch size */
            }
        }

        [x-cloak] { display: none !important; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { 
            background: #cbd5e1; 
            border-radius: 10px; 
        }

        /* Dark mode scrollbar */
        .dark .custom-scrollbar::-webkit-scrollbar-thumb { 
            background: #475569; 
        }

        /* Drag and drop styles */
        .sortable-ghost {
            opacity: 0.4;
            background-color: #e0e7ff;
        }
        
        .sortable-chosen {
            background-color: #f3f4f6;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .sortable-drag {
            opacity: 0.8;
            transform: rotate(2deg);
        }
        
        .group-sort-handle {
            cursor: move;
            user-select: none;
        }
        
        .sortable-handle {
            cursor: move;
            user-select: none;
        }
        
        .no-drag {
            cursor: default;
        }
        
        /* Dark mode transitions */
        * {
            transition: background-color 0.3s ease, border-color 0.3s ease;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none;      /* IE 10 and older */
            user-select: none;         /* Standard syntax */
        }
        
        .dark .sortable-ghost {
            background-color: #374151;
        }
        
        .dark .sortable-chosen {
            background-color: #4b5563;
        }

        /* Long press drag and drop styles */
        .group-card-item {
            position: relative;
            transition: transform 0.2s ease;
            touch-action: pan-y; /* Allow vertical scrolling but prevent horizontal */
        }

        .group-card-item:active {
            transform: scale(0.98);
        }

        .long-press-active {
            animation: pulse 0.5s infinite alternate;
        }

        @keyframes pulse {
            from {
                box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4);
            }
            to {
                box-shadow: 0 0 0 10px rgba(99, 102, 241, 0);
            }
        }

        .drag-mode-active .group-card-item {
            cursor: grab;
        }

        .drag-mode-active .group-card-item:active {
            cursor: grabbing;
        }
        
        .group-card-item.drag-handle-active {
            cursor: move;
            background-color: rgba(99, 102, 241, 0.05);
        }
    </style>
    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4f46e5">
    <link rel="apple-touch-icon" href="icon-192.png">

    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./service-worker.js')
            .then(reg => console.log('Service Worker registered', reg))
            .catch(err => console.error('Service Worker registration failed', err));
        });
      }
      // ADD THIS BLOCK TO PREVENT the mini-infobar from appearing on mobile
      window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); });
    </script>
    <!-- PWA -->
</head>
<body class="h-full flex flex-col bg-slate-50 text-slate-900 font-sans dark:bg-slate-900 dark:text-slate-100" x-data="app">
    <header class="bg-white border-b border-slate-200 sticky top-0 z-30 dark:bg-slate-800 dark:border-slate-700">
        <div class="max-w-7xl mx-auto px-4 h-16 md:h-10 flex items-center justify-between">
            <div class="flex items-center space-x-2">
                <div x-show="view !== 'detail'" class="flex items-center space-x-2 cursor-pointer" @click="view = 'list'">
                    <div class="bg-indigo-600 p-2 rounded-lg text-white">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                        </svg>
                    </div>
                    <h1 class="text-xl font-bold tracking-tight text-slate-800 dark:text-slate-100">Chronos</h1>
                    <div class="flex items-center space-x-3">
                        <div x-data="{ open: false }" class="relative" @click.away="open = false">
                            <button @click="open = !open" class="flex items-center space-x-2 px-3 py-2 text-sm font-medium text-slate-600 hover:bg-slate-100 rounded-lg transition-colors dark:text-slate-300 dark:hover:bg-slate-700">
                                <i class="fa-solid fa-file-import"></i>
                                <span>Data</span>
                                <i class="fa-solid fa-chevron-down text-[10px]"></i>
                            </button>

                            <div x-show="open" x-cloak 
                                 class="absolute right-0 mt-2 w-48 bg-white border border-slate-200 rounded-xl shadow-lg z-50 py-1 overflow-hidden dark:bg-slate-800 dark:border-slate-700">
                                
                                <div class="px-3 py-2 text-[10px] font-bold text-slate-400 uppercase tracking-widest border-b border-slate-50 dark:border-slate-700 dark:text-slate-500">Transfer</div>
                                
                                <button @click="exportData(); open = false" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-indigo-50 hover:text-indigo-600 flex items-center dark:text-slate-300 dark:hover:bg-slate-700 dark:hover:text-indigo-400">
                                    <i class="fa-solid fa-download w-5"></i> Export JSON
                                </button>
                                <label class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-indigo-50 hover:text-indigo-600 flex items-center cursor-pointer dark:text-slate-300 dark:hover:bg-slate-700 dark:hover:text-indigo-400">
                                    <i class="fa-solid fa-upload w-5"></i> Import JSON
                                    <input type="file" accept=".json,application/json" class="hidden" @change="importData($event); open = false">
                                </label>

                                <div class="border-t border-slate-100 my-1 dark:border-slate-700"></div>
                                
                                <button @click="exportCSV(); open = false" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-indigo-50 hover:text-indigo-600 flex items-center dark:text-slate-300 dark:hover:bg-slate-700 dark:hover:text-indigo-400">
                                    <i class="fa-solid fa-file-csv w-5"></i> Export CSV
                                </button>
                                <label class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-indigo-50 hover:text-indigo-600 flex items-center cursor-pointer dark:text-slate-300 dark:hover:bg-slate-700 dark:hover:text-indigo-400">
                                    <i class="fa-solid fa-file-import w-5"></i> Import CSV
                                    <input type="file" accept=".csv,text/csv" class="hidden" @change="importCSV($event); open = false">
                                </label>

                                <div class="border-t border-slate-100 my-1 dark:border-slate-700"></div>
                                
                                <!-- Theme Toggle -->
                                <button @click="toggleTheme(); open = false" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-indigo-50 hover:text-indigo-600 flex items-center dark:text-slate-300 dark:hover:bg-slate-700 dark:hover:text-indigo-400">
                                    <i class="fa-solid fa-moon w-5" x-show="theme === 'light'"></i>
                                    <i class="fa-solid fa-sun w-5" x-show="theme === 'dark'"></i>
                                    <span x-text="theme === 'light' ? 'Dark Mode' : 'Light Mode'"></span>
                                </button>
                            </div>
                        </div>
                        <div class="w-px h-6 bg-slate-200 dark:bg-slate-700"></div>
                        <button @click="modals.group = true; $nextTick(() => { const modal = document.querySelector('group-manager'); if (modal) modal.resetForm(); })" class="text-slate-600 hover:text-indigo-600 text-sm font-medium dark:text-slate-300 dark:hover:text-indigo-400">Groups</button>
                        <button @click="openNewSeriesModal()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors shadow-sm dark:bg-indigo-700 dark:hover:bg-indigo-600">
                            + New Series
                        </button>
                    </div>
                </div>

                <template x-if="currentSeries">
                <div x-show="view === 'detail'" class="flex items-center justify-between w-full ml-3">
                    <div class="flex items-center space-x-3 flex-1">
                        <button @click="view = 'list'" class="p-2 -ml-2 text-slate-500 hover:text-indigo-600 hover:bg-slate-100 rounded-full transition-colors dark:text-slate-400 dark:hover:text-indigo-400 dark:hover:bg-slate-800">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                            </svg>
                        </button>
                        <div class="relative flex items-center group cursor-text flex-1 max-w-md">
                            <input 
                                type="text" 
                                x-model="currentSeries.name" 
                                @change="updateSeriesName()"
                                @keydown.enter="$el.blur()"
                                class="bg-transparent border-b border-slate-300 focus:border-indigo-500 focus:bg-white dark:focus:bg-slate-800 text-xl font-bold tracking-tight text-slate-800 dark:text-slate-100 rounded-sm px-1 -ml-1 w-full outline-none transition-all pr-8"
                            >
                            <i class="fa-solid fa-pen text-[10px] text-slate-400 absolute right-2 pointer-events-none dark:text-slate-500"></i>
                        </div>
                    </div>
            
                    <button 
                        @click="if(confirm('Are you sure you want to delete this series?')) { deleteSeries(currentSeries.id); view = 'list'; }" 
                        class="p-2 text-slate-400 hover:text-red-600 hover:bg-red-50 rounded-full transition-colors dark:text-slate-500 dark:hover:text-red-400 dark:hover:bg-red-900/20"
                        title="Delete Series"
                    >
                        <i class="fa-solid fa-trash-can text-lg"></i>
                    </button>
                </div>
                </template>
            </div>
        </div>
    </header>

    <main class="flex-1 flex flex-col px-4 pb-1">
        <template x-if="view === 'list'">
            <div class="space-y-6">
                <div class="py-1 border-b border-slate-200 flex flex-wrap items-center gap-y-3 dark:border-slate-700" :class="!showFilters ? 'gap-x-8' : ''" x-data="{ showFilters: true }">
                    <div class="flex items-center gap-4">
                        <span @click="showFilters = !showFilters" 
                              class="text-[10px] font-bold text-slate-400 tracking-widest dark:text-slate-500 cursor-pointer hover:text-indigo-600 transition-colors select-none">
                            FILTER
                        </span>
                        <div x-show="showFilters" x-collapse>
                            <multi-select class="max-w-44 ml-2"
                                :items="JSON.stringify(groups.map(g => ({ id: g.name, label: g.name, color: g.color })))"
                                :selected-ids="JSON.stringify(selectedGroups)"
                                multi
                                @change="selectedGroups = $event.detail.selection; localStorage.setItem('chronos_selectedGroups', JSON.stringify(selectedGroups))">
                            </multi-select>
                        </div>
                    </div>
                </div>

                <div class="columns-1 min-[400px]:columns-2 md:columns-3 lg:columns-4 gap-3" id="groups-container">
                    <template x-for="(group, index) in filteredGroups" :key="group.id">
                        <div class="break-inside-avoid mb-3 group-card-item" 
                             :data-group-name="group.name"
                             :data-group-index="index"
                             :class="dragEnabled ? 'drag-mode-active' : ''"
                             @pointerdown="handlePointerDown($event, group, index)"
                             @pointerup="handlePointerUp($event)"
                             @pointercancel="handlePointerCancel($event)"
                             @pointerleave="handlePointerLeave($event)"
                             @pointermove="handlePointerMove($event)">
                            <group-card
                                :group="JSON.stringify(group)"
                                @series-click="openSeriesDetail($event.detail.series)"
                                @add-entry-click="openAddEntryModal($event.detail.series)"
                                @series-updated="loadSeries()"
                                @entry-created="loadSeries(); if(currentSeries && currentSeries.id === $event.detail.series.id) loadEntries(currentSeries.id)">
                            </group-card>
                        </div>
                    </template>
                </div>
            </div>
        </template>

        <template x-if="view === 'detail'">
            <div class="flex-1 flex flex-col space-y-2">
                <div class="flex-1 flex flex-col md:flex-row md:items-start md:gap-4">
                    <!-- Tabs container - will be on top in portrait, on right in landscape -->
                    <div class="flex md:flex-col items-center justify-between md:justify-start gap-4 py-2 border-b md:border-b-0 md:border-r border-slate-200 dark:border-slate-700 md:py-0 md:pr-4">                    
                        <div class="flex md:flex-col bg-slate-100 p-1 rounded-xl border border-slate-200 dark:bg-slate-800 dark:border-slate-700">
                            <template x-for="tab in [
                                {id: 'chart', icon: 'fa-chart-line'},
                                {id: 'calendar', icon: 'fa-calendar-days'},
                                {id: 'history', icon: 'fa-table-list'},
                                {id: 'config', icon: 'fa-gear'}
                            ]">
                                <button @click="changeSubView(tab.id)" 
                                        :class="detailSubView === tab.id ? 'bg-white text-indigo-600 shadow-sm dark:bg-slate-700 dark:text-indigo-400' : 'text-slate-500 dark:text-slate-400'" 
                                        class="px-3 py-1.5 rounded-lg text-sm transition-all flex justify-center items-center md:w-12 md:h-12">
                                    <i class="fa-solid" :class="tab.icon"></i>
                                </button>
                            </template>
                        </div>
                    </div>

                    <!-- Content area -->
                    <div class="flex-1 flex flex-col min-w-0 h-full">
                        <div x-show="detailSubView === 'chart'" class="flex-1 flex flex-col space-y-6">
                            <series-chart
                                class="flex-1 flex flex-col"
                                x-show="currentSeries"
                                :series-id="currentSeries?.id"
                                x-cloak>
                            </series-chart>
                        </div>

                        <div x-show="detailSubView === 'calendar'" class="space-y-6" x-cloak>
                            <chronos-calendar
                                x-show="detailSubView === 'calendar'"
                                :series="JSON.stringify(currentSeries)"
                                :entries="JSON.stringify(currentSeriesEntries)"
                                @day-click="handleCalendarDayClick($event.detail)">
                            </chronos-calendar>
                        </div>

                        <series-history 
                            x-show="detailSubView === 'history'"
                            :series="JSON.stringify(currentSeries)"
                            :entries="JSON.stringify(currentSeriesEntries)"
                            @add-entry-click="openAddEntryModal($event.detail.series)"
                            @edit-entry-click="editEntry($event.detail.entry)"
                            @delete-entry-click="deleteEntry($event.detail.id)"
                            x-cloak>
                        </series-history>

                        <series-configuration 
                            x-show="detailSubView === 'config'"
                            :series-id="currentSeries?.id"
                            x-cloak>
                        </series-configuration>
                    </div>
                </div>
            </div>
        </template>
    </main>

    <div x-show="modals.group" @keydown.window.escape="modals.group = false" class="fixed inset-0 z-50 overflow-y-auto" x-cloak>
      <div class="flex items-center justify-center min-h-screen px-4">
        <div class="fixed inset-0 bg-slate-900/50 backdrop-blur-sm" @click="modals.group = false"></div>
        <div class="bg-white rounded-2xl shadow-xl w-full max-w-md relative z-10 overflow-hidden dark:bg-slate-800">
          <group-manager @groups-updated="loadData()"></group-manager>
          <div class="px-6 py-4 bg-slate-50 border-t border-slate-100 flex justify-end dark:bg-slate-700 dark:border-slate-600">
            <button 
              @click="modals.group = false"
              class="text-sm font-medium text-slate-600 hover:text-slate-800 transition-colors dark:text-slate-400 dark:hover:text-slate-300">
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <div x-show="modals.series" @keydown.window.escape="modals.series = false" @keydown.enter="saveSeries()" class="fixed inset-0 z-50 overflow-y-auto" x-cloak>
        <div class="flex items-center justify-center min-h-screen px-4">
            <div class="fixed inset-0 bg-slate-900/50" @click="modals.series = false"></div>
            <div class="bg-white rounded-2xl shadow-xl w-full max-w-lg relative z-10 overflow-hidden dark:bg-slate-800">
                <div class="p-6">
                    <h3 class="text-xl font-bold text-slate-900 dark:text-slate-100" x-text="editingSeries ? 'Edit Series' : 'Create New Series'"></h3>
                    <div class="mt-6 space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-slate-700 dark:text-slate-300">Name</label>
                            <input type="text" x-model="seriesForm.name" class="w-full mt-1 px-4 py-2 border border-slate-200 rounded-lg outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100" autofocus>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-700 dark:text-slate-300">Type</label>
                            <select x-model="seriesForm.type" class="w-full mt-1 px-4 py-2 border border-slate-200 rounded-lg outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100">
                                <option value="number">Number</option>
                                <option value="time">Time</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-700 dark:text-slate-300">Group</label>
                            <select x-model="seriesForm.group" class="w-full mt-1 px-4 py-2 border border-slate-200 rounded-lg outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100">
                                <option value="">Uncategorized</option>
                                <template x-for="g in groups" :key="g.id"><option :value="g.name" x-text="g.name"></option></template>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="px-6 py-4 bg-slate-50 flex justify-end space-x-3 dark:bg-slate-700">
                    <button @click="modals.series = false" class="px-4 py-2 text-sm font-medium text-slate-700 dark:text-slate-300">Cancel</button>
                    <button @click="saveSeries()" class="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg dark:bg-indigo-700 dark:hover:bg-indigo-600">Save Series</button>
                </div>
            </div>
        </div>
    </div>

    <div x-show="modals.entry" @keydown.window.escape="modals.entry = false" @keydown.enter="saveEntry()" class="fixed inset-0 z-50 overflow-y-auto" x-cloak>
        <div class="flex items-center justify-center min-h-screen px-4">
            <div class="fixed inset-0 bg-slate-900/50" @click="modals.entry = false"></div>
            <div class="bg-white rounded-2xl shadow-xl w-full max-w-lg relative z-10 overflow-hidden dark:bg-slate-800">
                <div class="p-6">
                    <h3 class="text-xl font-bold text-slate-900 dark:text-slate-100" x-text="editingEntry ? 'Edit Entry' : 'Add New Entry'"></h3>
                    <div class="mt-6 space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-slate-700 dark:text-slate-300">Date & Time (yyyy-MM-dd HH:mm:ss)</label>
                            <input type="text" x-model="entryForm.timestamp" placeholder="2025-07-13 18:36:00" class="w-full mt-1 px-4 py-2 border border-slate-200 rounded-lg outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100" autofocus>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-slate-700 dark:text-slate-300">Value</label>
                            
                            <template x-if="activeSeriesForEntry?.type !== 'time'">
                                <input type="number" step="any" x-model="entryForm.value" class="w-full mt-1 px-4 py-2 border border-slate-200 rounded-lg outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100">
                            </template>

                            <template x-if="activeSeriesForEntry?.type === 'time'">
                                <div class="grid grid-cols-4 gap-2 mt-1">
                                    <div>
                                        <span class="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500">Days</span>
                                        <input type="number" x-model.number="entryForm.dhms.d" min="0" class="w-full px-2 py-2 border rounded-lg text-center outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100">
                                    </div>
                                    <div>
                                        <span class="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500">Hours</span>
                                        <input type="number" x-model.number="entryForm.dhms.h" min="0" max="23" class="w-full px-2 py-2 border rounded-lg text-center outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100">
                                    </div>
                                    <div>
                                        <span class="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500">Mins</span>
                                        <input type="number" x-model.number="entryForm.dhms.m" min="0" max="59" class="w-full px-2 py-2 border rounded-lg text-center outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100">
                                    </div>
                                    <div>
                                        <span class="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500">Secs</span>
                                        <input type="number" x-model.number="entryForm.dhms.s" min="0" max="59" class="w-full px-2 py-2 border rounded-lg text-center outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100">
                                    </div>
                                </div>
                            </template>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-slate-700 dark:text-slate-300">Notes (Optional)</label>
                            <input type="text" x-model="entryForm.notes" class="w-full mt-1 px-4 py-2 border border-slate-200 rounded-lg outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-slate-700 dark:border-slate-600 dark:text-slate-100">
                        </div>
                    </div>
                </div>
                <div class="px-6 py-4 bg-slate-50 flex justify-end space-x-3 dark:bg-slate-700">
                    <button @click="modals.entry = false" class="px-4 py-2 text-sm font-medium text-slate-700 dark:text-slate-300">Cancel</button>
                    <button @click="saveEntry()" class="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg dark:bg-indigo-700 dark:hover:bg-indigo-600">Save Entry</button>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed bottom-5 right-5 z-[100]" x-show="toast.show" x-transition x-cloak>
        <div class="bg-slate-800 text-white px-6 py-3 rounded-xl shadow-lg flex items-center space-x-3 dark:bg-slate-700">
            <span x-text="toast.message"></span>
            <button @click="toast.show = false" class="text-slate-400">&times;</button>
        </div>
    </div>
    <duration-picker-modal id="durationPickerModal"></duration-picker-modal>

    <script type="module">
        import Alpine from 'https://unpkg.com/alpinejs@3.x.x/dist/module.esm.js'
        import {formatDuration, secondsToDHMS, getFormattedISO} from './utils.js';
        import {calculateSeriesSummary} from './analytics.js';
        import chronosDB from './db.js';
        
        Alpine.data('app', () => ({
            formatDuration, secondsToDHMS, getFormattedISO,
            view: 'list', detailSubView: 'chart',
            series: [], groups: [], currentSeries: null, currentSeriesEntries: [],
            selectedGroups: [],
            sortPreferences: {}, // Store sorting preferences per group
            sortableInstances: [], // Store Sortable instances
            dragEnabled: false,
            isLongPressMode: false,
            longPressTimer: null,
            longPressDuration: 500, // milliseconds
            activePointerId: null, // Track which pointer is active
            draggingElement: null, // Track which element is being dragged
            dragStartPosition: { x: 0, y: 0 },
            dragStartIndex: null, // Track the index of the element being dragged
            pendingDragElement: null, // Element waiting to start dragging
            pendingDragIndex: null, // Index of element waiting to start dragging
            modals: { series: false, entry: false, group: false },
            editingSeries: null, 
            seriesForm: { 
                name: '', 
                group: '', 
                type: 'number', 
                config: {summaryMetrics:[], summaries:[], quickAddAction:'manual'}
            },
            editingEntry: null, activeSeriesForEntry: null, 
            entryForm: { timestamp: '', value: '', notes: '', dhms: { d:0, h:0, m:0, s:0 } },
            toast: { show: false, message: '' },
            theme: localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'),
            init() {
                this.initTheme();
                this.loadData();
                
                const savedGroups = localStorage.getItem('chronos_selectedGroups');
                if (savedGroups) this.selectedGroups = JSON.parse(savedGroups);
                
                // Load sorting preferences
                const savedSortPrefs = localStorage.getItem('chronos_sortPreferences');
                if (savedSortPrefs) this.sortPreferences = JSON.parse(savedSortPrefs);
                
                // Initialize drag and drop (disabled by default)
                this.initializeGroupSortable();
                
                // Start long-press detection after groups are rendered
                this.$nextTick(() => {
                    this.startLongPressDetection();
                });
                
                // Escape key disables drag
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.dragEnabled) {
                        this.disableDragAndDrop();
                    }
                });
                
                // Click outside disables drag (except when dragging)
                document.addEventListener('pointerdown', (e) => {
                    if (this.dragEnabled && !e.target.closest('.group-card-item')) {
                        this.disableDragAndDrop();
                    }
                });
            },

            async loadData() {
                await this.loadGroups();
                await this.loadSeries();
            },

            toggleTheme() {
                this.theme = this.theme === 'light' ? 'dark' : 'light';
                
                localStorage.setItem('theme', this.theme);
                
                if (this.theme === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            },

            initTheme() {
                const storedTheme = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const isDark = storedTheme === 'dark' || (!storedTheme && prefersDark);
                
                this.theme = isDark ? 'dark' : 'light';
                
                if (isDark) { 
                    document.documentElement.classList.add('dark');
                } else {      
                    document.documentElement.classList.remove('dark'); 
                }
            },

            async exportData() {
                try {
                    const exportObj = await chronosDB.exportJSON();
                    const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `chronos_export_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    this.showToast('JSON Exported');
                } catch (err) {
                    this.showToast('Export failed');
                }
            },

            async importData(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const importObj = JSON.parse(e.target.result);
                        if (!confirm("Merge imported data?")) return;
                        await chronosDB.importJSON(importObj, true);
                        await this.loadData();
                        this.showToast('Data merged');
                    } catch (err) { 
                        alert("Invalid JSON file"); 
                    }
                };
                reader.readAsText(file);
            },

            async exportCSV() {
                try {
                    const csv = await chronosDB.exportCSV();
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.setAttribute("download", `chronos_export_${new Date().toISOString().split('T')[0]}.csv`);
                    link.click();
                    this.showToast('CSV Exported');
                } catch (err) {
                    this.showToast('CSV Export failed');
                }
            },

            async importCSV(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        await chronosDB.importCSV(e.target.result);
                        await this.loadData();
                        this.showToast("CSV Imported Successfully");
                    } catch (err) {
                        alert("Failed to import CSV");
                    }
                };
                reader.readAsText(file);
            },

            async loadGroups() {
                this.groups = await chronosDB.getAllGroups();
                this.groups.sort((a,b) => a.name.localeCompare(b.name));
            },


            async loadSeries() {
                this.series = await chronosDB.getAllSeries();
            },

            get filteredSeries() {
                let res = this.series.filter(s => this.selectedGroups.length === 0 || this.selectedGroups.includes(s.group || ''));
                // Sort by group first, then by name within each group
                return res.sort((a, b) => {
                    const groupA = (a.group || '').toLowerCase();
                    const groupB = (b.group || '').toLowerCase();
                    
                    if (groupA !== groupB) {
                        return groupA.localeCompare(groupB);
                    }
                    
                    // Same group, sort by name
                    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                });
            },

            get filteredGroups() {
                // Get unique groups from filtered series
                const filteredSeries = this.filteredSeries;
                const groupNames = [...new Set(filteredSeries.map(s => s.group).filter(g => g))];
                
                // Create group objects with their series
                return this.groups
                    .filter(g => groupNames.includes(g.name))
                    .map(group => ({
                        ...group,
                        seriesCount: filteredSeries.filter(s => s.group === group.name).length
                    }))
                    .sort((a, b) => a.name.localeCompare(b.name));
            },

            openNewSeriesModal() { 
                this.editingSeries = null; 
                this.seriesForm = { name: '', group: '', type: 'number', config: { stat: 'mean', period: 'all', quickAddAction: 'manual' } }; 
                this.modals.series = true; 
            },
            
            
            async updateSeriesName() {
                if (!this.currentSeries || !this.currentSeries.name.trim()) return;
                const index = this.series.findIndex(s => s.id === this.currentSeries.id);
                if (index !== -1) {
                    this.series[index].name = this.currentSeries.name;
                }
                await chronosDB.saveSeries(this.currentSeries);
                await this.loadSeries();
            },

            async deleteSeries(id) {
                if (!confirm('Delete series and all data?')) return;
                await chronosDB.deleteSeries(id);
                await this.loadSeries();
                if (this.currentSeries?.id === id) this.view = 'list';
                this.showToast('Deleted');
            },

            async saveSeries() {
                if (!this.seriesForm.name) return;
                await chronosDB.saveSeries(this.seriesForm);
                await this.loadSeries();
                this.modals.series = false;
                this.showToast('Saved');
            },

            async openSeriesDetail(series) {
                this.currentSeries = series;            
                this.view = 'detail';
                this.detailSubView = 'chart';
                await this.loadEntries(series.id);
            },

            async loadEntries(id) {
                this.currentSeriesEntries = await chronosDB.getEntriesForSeries(id);
                this.currentSeriesEntries.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
                this.recalculateSummaryDisplay();
            },

            recalculateSummaryDisplay() {
                if (!this.currentSeries || !this.currentSeriesEntries.length || !this.currentSeries.config) return;
                
                // Calculate multiple summaries if summaries array exists
                if (this.currentSeries.config.summaries && Array.isArray(this.currentSeries.config.summaries)) {
                    this.currentSeries.summaryDisplay = this.currentSeries.config.summaries.map(summaryConfig => {
                        return calculateSeriesSummary(
                            this.currentSeries,
                            this.currentSeriesEntries,
                            formatDuration.bind(this),
                            summaryConfig
                        );
                    }).filter(summary => summary && summary.trim() !== '');
                } else {
                    // Fallback to single summary for backward compatibility
                    this.currentSeries.summaryDisplay = calculateSeriesSummary(
                        this.currentSeries,
                        this.currentSeriesEntries,
                        formatDuration.bind(this)
                    );
                }
            },

            handleCalendarDayClick(d) {
                this.activeSeriesForEntry = this.currentSeries;
                this.editingEntry = null;
                const now = new Date();
                const targetDate = new Date(d.date);
                targetDate.setHours(now.getHours(), now.getMinutes());
                this.entryForm = { timestamp: getFormattedISO(targetDate), value: '', notes: '', dhms: { d:0, h:0, m:0, s:0 } };
                this.modals.entry = true;
            },

            changeSubView(v) { this.detailSubView = v; },
            
            async openAddEntryModal(series) {
                const action = series.config?.quickAddAction;
                if (action && action !== 'manual') {
                    await chronosDB.quickAction(series);
                    await this.loadSeries();
                    if (this.currentSeries && this.currentSeries.id === series.id) {
                        await this.loadEntries(series.id);
                    }
                    return;
                }

                this.activeSeriesForEntry = series;
                this.editingEntry = null;
                this.entryForm = {timestamp: getFormattedISO(), value: 0, notes: '', dhms: { d: 0, h: 0, m: 0, s: 0 } };
                this.modals.entry = true;
            },
            
            async saveEntry() {
                if (!this.entryForm.timestamp) return;
                let finalVal;
                if (this.activeSeriesForEntry.type === 'time') {
                    const {d, h, m, s} = this.entryForm.dhms;
                    finalVal = (parseInt(d||0)*86400) + (parseInt(h||0)*3600) + (parseInt(m||0)*60) + parseInt(s||0);
                } else { 
                    finalVal = parseFloat(this.entryForm.value); 
                }
                if (isNaN(finalVal)) return;

                let cleanTimestamp = this.entryForm.timestamp.replace('T', ' ');
                const entryData = { 
                    timestamp: cleanTimestamp, 
                    notes: this.entryForm.notes, 
                    seriesId: this.activeSeriesForEntry.id, 
                    value: finalVal 
                };
                
                if (this.editingEntry) entryData.id = this.editingEntry.id;
                
                await chronosDB.saveEntry(entryData);
                
                // Update series summary
                const allEntries = await chronosDB.getEntriesForSeries(this.activeSeriesForEntry.id);
                const tempSeries = JSON.parse(JSON.stringify(this.activeSeriesForEntry));
                tempSeries.summaryDisplay = calculateSeriesSummary(tempSeries, allEntries, formatDuration.bind(this));
                await chronosDB.saveSeries(tempSeries);
                
                await this.loadSeries();
                if (this.currentSeries && this.currentSeries.id === this.activeSeriesForEntry.id) {
                    await this.loadEntries(this.activeSeriesForEntry.id);
                }
                this.modals.entry = false;
                this.showToast('Saved');
            },

            editEntry(e) { 
                this.activeSeriesForEntry = this.currentSeries; 
                this.editingEntry = e; 
                this.entryForm = { ...e, dhms: this.activeSeriesForEntry.type === 'time' ? secondsToDHMS(e.value) : { d:0, h:0, m:0, s:0 } }; 
                this.modals.entry = true; 
            },

            async deleteEntry(id) { 
                if (confirm('Delete entry?')) { 
                    await chronosDB.deleteEntry(id);
                    await this.loadEntries(this.currentSeries.id);
                } 
            },

            // Pointer event handlers for long press
            handlePointerDown(event, group, index) {
                // Only handle primary pointer (left mouse button or first touch)
                if (event.button !== 0 && event.pointerType === 'mouse') return;
                
                // If drag is already enabled, let Sortable handle it
                if (this.dragEnabled) return;
                
                // Store the pointer ID
                this.activePointerId = event.pointerId;
                
                // Capture references BEFORE the timeout
                const element = event.currentTarget;
                const clientX = event.clientX;
                const clientY = event.clientY;
                
                // Store which element might be dragged
                this.draggingElement = element;
                this.dragStartPosition = { x: clientX, y: clientY };
                this.dragStartIndex = index;
                
                // Start long press timer with captured references
                this.longPressTimer = setTimeout(() => {
                    // Enable drag mode AND immediately start dragging this element
                    this.startDragOnElement(element, index, clientX, clientY);
                    
                    // Add visual feedback
                    element.classList.add('drag-handle-active');
                    
                    // Prevent default behavior
                    event.preventDefault();
                }, this.longPressDuration);
            },

            handlePointerUp(event) {
                // Only handle the active pointer
                if (event.pointerId !== this.activePointerId) return;
                
                this.cancelLongPress();
                
                // Remove visual feedback
                if (this.draggingElement) {
                    this.draggingElement.classList.remove('drag-handle-active');
                }
                
                this.activePointerId = null;
                this.draggingElement = null;
                this.dragStartIndex = null;
            },

            handlePointerCancel(event) {
                // Only handle the active pointer
                if (event.pointerId !== this.activePointerId) return;
                
                this.cancelLongPress();
                
                // Remove visual feedback
                if (this.draggingElement) {
                    this.draggingElement.classList.remove('drag-handle-active');
                }
                
                this.activePointerId = null;
                this.draggingElement = null;
                this.dragStartIndex = null;
            },

            handlePointerLeave(event) {
                // Only handle the active pointer
                if (event.pointerId !== this.activePointerId) return;
                
                // Don't cancel long press if pointer leaves, just track it
            },

            handlePointerMove(event) {
                // If we're waiting for long press and pointer has moved too much, cancel
                if (this.longPressTimer && this.dragStartPosition) {
                    const moveThreshold = 10; // pixels
                    const dx = Math.abs(event.clientX - this.dragStartPosition.x);
                    const dy = Math.abs(event.clientY - this.dragStartPosition.y);
                    
                    if (dx > moveThreshold || dy > moveThreshold) {
                        this.cancelLongPress();
                        if (this.draggingElement) {
                            this.draggingElement.classList.remove('drag-handle-active');
                        }
                    }
                }
            },

            cancelLongPress() {
                if (this.longPressTimer) {
                    clearTimeout(this.longPressTimer);
                    this.longPressTimer = null;
                }
            },

            startDragOnElement(element, index, clientX, clientY) {
                // First enable drag mode
                this.dragEnabled = true;
                
                // Enable the Sortable instance
                if (this.sortableInstances[0]) {
                    const sortable = this.sortableInstances[0];
                    sortable.option('disabled', false);
                    
                    // Now trigger the drag start on the specific element
                    this.$nextTick(() => {
                        // Create a simulated event to trigger drag
                        const dragStartEvent = new MouseEvent('mousedown', {
                            bubbles: true,
                            cancelable: true,
                            clientX: clientX,
                            clientY: clientY,
                            button: 0,
                            view: window
                        });
                        
                        // Dispatch the event on the element
                        element.dispatchEvent(dragStartEvent);
                        
                        // After a short delay, trigger a mousemove to start dragging
                        setTimeout(() => {
                            const dragMoveEvent = new MouseEvent('mousemove', {
                                bubbles: true,
                                cancelable: true,
                                clientX: clientX + 5,
                                clientY: clientY + 5,
                                button: 0,
                                view: window
                            });
                            
                            document.dispatchEvent(dragMoveEvent);
                        }, 10);
                    });
                }
                
                // Visual feedback
                document.body.style.cursor = 'grab';
                this.showToast('Drag mode enabled - move to reorder');
                
                // Add overlay to indicate drag mode
                const overlay = document.createElement('div');
                overlay.id = 'drag-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(99, 102, 241, 0.1);
                    z-index: 9998;
                    pointer-events: none;
                `;
                document.body.appendChild(overlay);
            },

            // Long press drag and drop methods
            initializeGroupSortable() {
                // Destroy any existing Sortable instances
                this.destroySortable();
                
                this.$nextTick(() => {
                    const groupsContainer = document.getElementById('groups-container');
                    if (!groupsContainer) return;
                    
                    // Initialize Sortable but disable it initially
                    const sortable = Sortable.create(groupsContainer, {
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        chosenClass: 'sortable-chosen',
                        dragClass: 'sortable-drag',
                        disabled: true, // Initially disabled
                        delay: 200, // Small delay to prevent accidental drags
                        delayOnTouchOnly: false,
                        onStart: (evt) => {
                            // When drag starts, show visual feedback
                            document.body.style.cursor = 'grabbing';
                            // Remove any active visual feedback
                            document.querySelectorAll('.drag-handle-active').forEach(el => {
                                el.classList.remove('drag-handle-active');
                            });
                        },
                        onEnd: (evt) => {
                            document.body.style.cursor = '';
                            this.handleGroupSortEnd(evt.oldIndex, evt.newIndex);
                            this.disableDragAndDrop(); // Disable after drag ends
                        }
                    });
                    
                    this.sortableInstances = [sortable];
                    this.applySavedGroupOrder();
                });
            },

            disableDragAndDrop() {
                if (!this.dragEnabled) return;
                
                this.dragEnabled = false;
                
                // Disable the Sortable instance
                if (this.sortableInstances[0]) {
                    this.sortableInstances[0].option('disabled', true);
                }
                
                // Remove visual feedback
                document.body.style.cursor = '';
                
                // Remove overlay
                const overlay = document.getElementById('drag-overlay');
                if (overlay) {
                    overlay.remove();
                }
                
                // Remove any active visual feedback
                document.querySelectorAll('.drag-handle-active').forEach(el => {
                    el.classList.remove('drag-handle-active');
                });
                
                // Clear dragging element
                this.draggingElement = null;
                this.dragStartIndex = null;
                
                this.showToast('Drag mode disabled');
            },

            destroySortable() {
                if (this.sortableInstances) {
                    this.sortableInstances.forEach(instance => instance.destroy());
                    this.sortableInstances = [];
                }
            },
            
            handleGroupSortEnd(oldIndex, newIndex) {
                if (oldIndex === newIndex) return;
                
                // Get the current filtered groups
                const currentGroups = [...this.filteredGroups];
                
                // Reorder the groups
                const [movedItem] = currentGroups.splice(oldIndex, 1);
                currentGroups.splice(newIndex, 0, movedItem);
                
                // Update sort preferences
                this.sortPreferences.groupOrder = currentGroups.map(g => g.name);
                localStorage.setItem('chronos_sortPreferences', JSON.stringify(this.sortPreferences));
                
                this.showToast('Group order saved');
            },
            
            applySavedGroupOrder() {
                const groupOrder = this.sortPreferences.groupOrder;
                if (!groupOrder || !Array.isArray(groupOrder)) return;
                
                const groupsContainer = document.getElementById('groups-container');
                if (!groupsContainer) return;
                
                // Get all group card items
                const groupItems = Array.from(groupsContainer.querySelectorAll('.group-card-item'));
                
                // Sort group items based on saved order
                groupItems.sort((a, b) => {
                    const aName = a.getAttribute('data-group-name');
                    const bName = b.getAttribute('data-group-name');
                    const aIndex = groupOrder.indexOf(aName);
                    const bIndex = groupOrder.indexOf(bName);
                    
                    // If a group is not in the saved order, put it at the end
                    if (aIndex === -1) return 1;
                    if (bIndex === -1) return -1;
                    
                    return aIndex - bIndex;
                });
                
                // Reappend group items in correct order
                groupItems.forEach(item => groupsContainer.appendChild(item));
            },

            showToast(m) { this.toast.message = m; this.toast.show = true; setTimeout(() => this.toast.show = false, 3000); }
        }));
        
        Alpine.start();
    </script>
</body>
</html>
